시스템 로그와 게임로그

게임로그

	- 게임로그는 DB 에 저장한다. 파일저장은 의미가 없음.

	- 게임 데이터가 저장,변경되는 순간에 함께 기록.
	- DB 저장 트랜젝션과 함께 처리.
	- 트랜젝션을 안하더라도 DB 쿼리와 함께 로그쿼리 전송
	- 게임 데이터가 변경 되었다면 로그도 남겨져야 함.

	- 게임로그는 일반적으로 다음과 같은 형태를 가질 수 있음.


	Server / Type / Code / AccountNo / Param1 / Param2 / Param3 / Param4 / ParamStr ...

	모든 로그에 대해서 위와 같은 똑같은 포멧을 사용.
	되도록 모든 컬럼은 숫자 타입을 사용하는게 좋다.
	숫자만으로 표현이 안되는 경우는 마지막 컬럼을 스트링으로 하여 사용.

	로그 테이블은 분류별로 나누지 않고, 기간별로 나눈다.




	!! 처음에 가장 많이하는 실수

	로그의 분산을 위해서 Item, Character, Quest 처럼 컨텐츠 별로 로그 테이블을 나눔
	이렇게 되면 관리도 검색도 힘들고 쿼리가 쌓였을 때 처리가 더욱더 곤란해짐.

	월단위 또는 주단위, 또는 대박나서 게임이 로그가 너무 많이 쌓인다면
	일단위로 모든 로그를 하나의 테이블에 남기며 기간별로 분리한다.

	


시스템로그

	- 개발과정에서 원하는 문자열을 모니터,파일,DB,웹 등으로 저장
	- PHP 용으로 만들었던 로그 저장과 비슷

	
	필수요소

	- 로그분류 / 날짜,시간 / 문자열
	- 파일저장시 - 분류별로 월별로 파일 나누어 지도록.
	- DEBUG / WARNING / ERROR / SYSTEM 등 4단계로 로그 기록 설정.
	- 코드 설정을 통해서 콘솔/파일/DB/웹 선택이 가능해야 함 (비트연산자로 중복가능)


	사용예)

	* 전역함수 또는 싱글톤으로 구현.

	SYSLOG_DIRECTORY(L"Log_MatchmakingServer");
	SYSLOG_LEVEL(LOG::LEVEL_ERROR);

//	LOG_SET(LOG::CONSOLE | LOG:FILE | LOG::DB, LOG::LEVEL_ERROR);


	void Log(WCHAR *szType, en_LOG_LEVEL LogLevel, WCHAR *szStringFormat, ...);

	LOG("Battle", LOG::LEVEL_DEBUG, "[DBAcc]:%u [Slot]:%d [GameAcc]:%d d [RandKey]:%d", a,b,c,d,e,....);




	위와 같이 서버 초기화 시 출력방법과 로그 대상을 선택하고 어디서든 LOG 를 호출하여 출력!
	LOG 의 첫번째 인자에는 로그 분류, 두번째 인자에는 레벨, 세번째 인자에는 문자열 기입.


	# 모든 로그 저장은 설정레벨 (DEBUG, WARNING, ERROR) 과 
	# 호출시 로그 레벨을 비교하여 상위 레벨의 경우에만 저장을 한다.

	DEBUG 모드 : DEBUG, WARNING, ERROR 모두 저장
	WARNING 모드 : WARNING, ERROR 저장
	ERROR 모드 : ERROR 저장

	# 파일저장시 -----------------------------------------------

	파일이름 : LOG 의 첫번째 인자 '타입' + 년월.txt 로 저장.

	경험상 일단위는 파일이 너무 쪼개지며 주단위는 분류가 애매함
	월단위 저장이 가장 관리가 편리.

	ex) 201509_Battle.txt


	파일내용 : 
	
		[Battle] [2015-09-11 19:00:00 / DEBUG] 로그문자열.........	
		[Battle] [2015-09-11 19:00:01 / WARNG] 로그문자열.........	
		[Battle] [2015-09-11 19:00:01 / ERROR] 로그문자열.........	
	
		위와 같이 줄 단위로 

		종류 / 날짜,시간 / 로그레벨 / 로그문자열 을 저장.

		로그문자열 앞까지는 줄을 맞춰 주는게 필요함.
		줄이 안맞아 버리면 대량의 로그를 확인하는 과정이 힘들어짐.


		조금 더 기능을 추가 한다면 로그카운터를 주어서 남기는것도 도움이 됨.

		[Battle] [2015-09-11 19:00:00 / DEBUG / 000000001] 로그문자열.........	
		[Battle] [2015-09-11 19:00:01 / WARNG / 000000002] 로그문자열.........	
		[Battle] [2015-09-11 19:00:01 / ERROR / 000000003] 로그문자열.........	
	
		위에 추가된 카운트는 로그를 남길 때 마다 스레드에 안전하게 +1 되는 숫자.

		이 카운터의 용도 로그의 순서를 파악하는데 도움이 된다.
		시간의 초만 가지고는 로그의 순서가 정확하지 않기 때문.

		파일로그의 경우 Type 별로 파일을 분리시켜 저장 할 것임.
		DB 에서는 하나의 테이블에 몰아서 저장하지만 파일은 분류별로 나누는 이유는
		DB 는 검색이 용이하지만 파일은 검색이 어렵기 때문에 종류별로 나누는게 확인이 편리.

		201509_Battle.txt

		[Battle] [2015-09-11 19:00:00 / DEBUG / 000000001] 로그문자열.........	
		[Battle] [2015-09-11 19:00:01 / WARNG / 000000004] 로그문자열.........	
		[Battle] [2015-09-11 19:00:01 / ERROR / 000000006] 로그문자열.........	

	
		201509_Item.txt	

		[Item] [2015-09-11 19:00:00 / DEBUG / 000000002] 로그문자열.........	
		[Item] [2015-09-11 19:00:01 / DEBUG / 000000003] 로그문자열.........	
		[Item] [2015-09-11 19:00:01 / DEBUG / 000000005] 로그문자열.........	
	

		위와 같이 2개의 로그 파일이 남겨질 때 한 로직의 과정에서
		여러개의 로그 파일로 저장이 되기도 하는데 이에 대해 정확한 순서 확인이 
		필요하다면 로그 카운터를 확인하면 된다.


		
		* 파일 저장 구현시 참고사항

		LOG(xxxxxxx); 
		
		함수 호출시 매번  File Open > Write > File Close  하는 것을 기본으로 한다.

		로그를 남길 때마다 매번 파일을 열고닫고 하는 부분이 굉장히 효율이 떨어지지만
		두가지 이유가 있음.

		1. 서버가 운영되는 상황에서 로그 파일을 열고 확인이 가능해야 한다.
		2. 여러 스레드가 동시에 접근시 파일의 Open, Close 를 통해 동기화가 가능하다.
		   (한 스레드에서 파일을 오픈시 다른 스레드는 자동으로 파일을 열지 못함)

		이 두가지를 위해서 매 호출마다 열고>쓰고>닫고 를 반복 함.

		 	



	void Log(WCHAR *szType, en_LOG_LEVEL LogLevel, WCHAR *szStringFormat, ...);
	void LogHex(WCHAR *szType, en_LOG_LEVEL LogLevel, WCHAR *szLog, BYTE *pByte, int iByteLen);

	//------------------------------------------------------
	// SessionKey 64개 출력 전용. 이는 문자열이 아니라서 마지막에 널이 없음.
	//------------------------------------------------------
	void LogSessionKey(WCHAR *szType, en_LOG_LEVEL LogLevel, WCHAR *szLog, BYTE *pSessionKey);







	# CONSOLE (화면출력) ----------------------------

		파일에 저장되는 내용 그대로를 화면에 printf 로 출력만 해주면 된다.
		간혹 문자열이 너무 길어져서 보기가 힘들다면 로그 카운터나 로그레벨 등
		불필요한 일부 항목을 제외 하는것도 좋다.


		
	# DB 저장시 -------------------------------------

		DB 에는 게임로그와 같이 월단위로 모아서 한번에 저장을 해주면 된다.
		
		다만 DB 저장은 데이터베이스의 접속정보 및 DB 컬럼등에 영향을 받기 때문에
		추가적인 설정이 필요하다. 이는 본 로그 클래스 또는 로그 소스파일 헤더에
		상세히 기록하여 다른 사람이 보아도 활용할 수 있도록 한다.


		// DB 접속정보 설정 방법
		// DB 테이블 구조
		// 로그시스템 사용을 위한 DB 테이블 생성 스키마

		시스템 로그 저장을 비동기로 (별도 쿼리전송 스레드를 두어서) 처리도 가능하지만
		시스템 로그는 서버가 죽거나 할 때 이를 확인해야 하므로 비동기 저장 보다는
		동기 저장으로 확실하게 저장 하도록 한다.

		DB 저장은 파일처럼 나누어서 저장되지 않으므로 하나의 동기화 객체를 사용하여
		순서를 정확하게 잡아주는게 필요.


		LOG 클래스 또는 LOG 객체 내부에 DB 연결정보 객체,함수 등을 독립적으로 내장 한다.
		(외부에 만들어진 DB 연결 객체를 사용하지 않는다는 의미)


	# 웹저장시 -----------------------------------------------

		웹 저장 역시 DB 와 같이 외부의 URL 에 영향을 받는 방법 이므로
		이는 본 LOG 시스템과 웹 PHP,DB 까지 패키지로 묶여 다녀야 한다.

		웹 저장은 옵션 사항이므로 필수 구현은 아님

		

	각 저장 방식에 따른 장단점.

	콘솔출력 - 모니터로 바로 확인이 됨. (기본으로 사용)
	파일출력 - 개발 중 서비스 중 저장하며 정확하게 확인 가능. (기본으로 사용)
	디비출력 - DB 테이블에 저장되므로 실제 서버 컴퓨터에 접근 없이 확인 가능.
	웹출력 - DB 에 저장은 하고 싶지만 DB 연결이 안되는 상황에 외부 DB 로 저장 가능.
